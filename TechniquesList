-Si hay operaciones sobre prefijos, considerar ir de atrás para adelante para que operaciones nuevas no arruinen las anteriores.
-Mínima cantidad de swaps adyacentes -> contar inversiones con segtree o mergesort.
-En problemas de mediana, pensar que si la mediana es x en un intervalo y reemplazas los elementos menores a x con -1 y los mayores o iguales a x con +1,
entonces la suma del intervalo es > 0.
-Si el espacio de búsqueda es chico, mandale con dfs/bfs.
-Si tenés que maximizar/minimizar/hacer algo son sum(ai)/sum(bi), pensá en usar búsqueda binaria.
-Si te piden minimizar algo, pensá en maximizar otra cosa. Se usa mucho en problemas que involucran LIS. Para minimizar la cantidad de cambios,
es equivalente maximizar la cantidad que no cambias.
-Fijarse qué ventaja podría dar ver los elementos en un cierto orden, ya sea de menor a mayor o alguna otra cosa.
-Fijarse en problemas de juegos/maximizar/minimizar, qué cosas NUNCA conviene hacer/qué cosas no conviene cambiar.
-En problemas de operaciones/cambios, fijarse qué elementos solo pueden cambiar de una forma.
-Probar pintar como ajedrez, partir en subtableros de 2x2, pintar con 4 colores, etc.
-En general, es más fácil calcular múltiplos que divisores, por lo que conviene usar criba.
-En problemas constructivos, pensar siempre en elegir al siguiente más cerca, más lejos, al que minimice algo, etc.
-En problemas de bits, el xor nos permite saber qué bits están encendidos, dado que 1^1=0, 0^1=1.
-En problemas de grafos, pensar si el problema en un árbol es más fácil y luego ver cómo trabajar con las back-edges.
-Ver qué números/elementos son candidatos a ser la respuesta/el mínimo/máximo.
